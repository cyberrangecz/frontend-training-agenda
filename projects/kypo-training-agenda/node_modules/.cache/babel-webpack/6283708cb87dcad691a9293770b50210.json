{"ast":null,"code":"import { async, TestBed } from '@angular/core/testing';\nimport { SentinelPagination, PaginatedResource, asyncData, RequestedPagination } from '@sentinel/common';\nimport { UserApi } from '@muni-kypo-crp/training-api';\nimport { throwError } from 'rxjs';\nimport { skip, take } from 'rxjs/operators';\nimport { createContext, createErrorHandlerSpy, createUserApiSpy } from '../../../../../internal/src/testing/testing-commons.spec';\nimport { TrainingErrorHandler } from '../../../../../src/services/training-error.handler.service';\nimport { TrainingAgendaContext } from '../../../../../internal/src/services/context/training-agenda-context.service';\nimport { AuthorsAssignService } from './authors-assign.service';\ndescribe('AuthorsAssignService', () => {\n  let errorHandlerSpy;\n  let apiSpy;\n  let service;\n  let context;\n  beforeEach(async(() => {\n    errorHandlerSpy = createErrorHandlerSpy();\n    apiSpy = createUserApiSpy();\n    context = createContext();\n    TestBed.configureTestingModule({\n      providers: [AuthorsAssignService, {\n        provide: UserApi,\n        useValue: apiSpy\n      }, {\n        provide: TrainingErrorHandler,\n        useValue: errorHandlerSpy\n      }, {\n        provide: TrainingAgendaContext,\n        useValue: context\n      }]\n    });\n    service = TestBed.inject(AuthorsAssignService);\n  }));\n  it('should be created', () => {\n    expect(service).toBeTruthy();\n  });\n  it('should load authors from facade (called once)', done => {\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const pagination = createPagination();\n    service.getAssigned(0, pagination).subscribe(() => done(), fail);\n    expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n  });\n  it('should load designers from facade (called once)', done => {\n    apiSpy.getDesignersNotInTD.and.returnValue(asyncData(createMock()));\n    service.getAvailableToAssign(0).subscribe(() => done(), fail);\n    expect(apiSpy.getDesignersNotInTD).toHaveBeenCalledTimes(1);\n  });\n  it('should assign designers through facade (called once)', done => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToAssign = createMock().elements;\n    const idsToAssign = usersToAssign.map(user => user.id);\n    service.assign(0, usersToAssign).subscribe(() => done(), fail);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledTimes(1);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledWith(0, idsToAssign, false, []);\n  });\n  it('should refresh authors after assign action', done => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToAssign = createMock().elements;\n    service.assign(0, usersToAssign).subscribe(() => {\n      expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n      done();\n    }, fail);\n  });\n  it('should unassign authors through facade (called once)', done => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToUnassign = createMock().elements;\n    const idsToUnassign = usersToUnassign.map(user => user.id);\n    service.unassign(0, usersToUnassign).subscribe(() => done(), fail);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledTimes(1);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledWith(0, [], false, idsToUnassign);\n  });\n  it('should refresh authors after unassign action', done => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToUnassign = createMock().elements;\n    service.unassign(0, usersToUnassign).subscribe(() => {\n      expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n      done();\n    }, fail);\n  });\n  it('should call error handler on err (getAvailableToAssign)', done => {\n    apiSpy.getDesignersNotInTD.and.returnValue(throwError(null));\n    service.getAvailableToAssign(0).subscribe(() => fail, () => {\n      expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n      done();\n    });\n  });\n  it('should call error handler on err (getAssigned)', done => {\n    apiSpy.getAuthors.and.returnValue(throwError(null));\n    service.getAssigned(0, null).subscribe(() => fail, () => {\n      expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n      done();\n    });\n  });\n  it('should call error handler on err (assign)', done => {\n    apiSpy.updateAuthors.and.returnValue(throwError(null));\n    service.assign(0, []).subscribe(() => fail, () => {\n      expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n      done();\n    });\n  });\n  it('should call error handler on err (unassign)', done => {\n    apiSpy.updateAuthors.and.returnValue(throwError(null));\n    service.unassign(0, []).subscribe(() => fail, () => {\n      expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n      done();\n    });\n  });\n  it('should emit hasError on err', done => {\n    apiSpy.getAuthors.and.returnValue(throwError(null));\n    const pagination = createPagination();\n    service.hasError$.pipe(skip(2)) // we ignore initial value and value emitted before the call is made\n    .subscribe(emitted => {\n      expect(emitted).toBeTruthy();\n      done();\n    }, fail);\n    service.getAssigned(0, pagination).pipe(take(1)).subscribe(fail, _ => _);\n  });\n  it('should emit next value on getAuthors', done => {\n    const mockData = createMock();\n    apiSpy.getAuthors.and.returnValue(asyncData(mockData));\n    const pagination = createPagination();\n    service.assignedUsers$.pipe(skip(1)).subscribe(emitted => {\n      expect(emitted).toBe(mockData);\n      done();\n    }, fail);\n    service.getAssigned(0, pagination).pipe(take(1)).subscribe(_ => _, fail);\n  });\n\n  function createPagination() {\n    return new RequestedPagination(1, 5, '', '');\n  }\n\n  function createMock() {\n    const user1 = {\n      id: 1,\n      name: '',\n      login: '',\n      mail: '',\n      picture: ''\n    };\n    const user2 = {\n      id: 2,\n      name: '',\n      login: '',\n      mail: '',\n      picture: ''\n    };\n    return new PaginatedResource([user1, user2], new SentinelPagination(1, 2, 5, 2, 1));\n  }\n});","map":{"version":3,"sources":["/home/dominik/Desktop/Workspace/FRONTEND/kypo-training-agenda/projects/kypo-training-agenda/definition-edit/src/services/state/authors-assign/authors-assign.service.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { async, TestBed } from '@angular/core/testing';\nimport { SentinelPagination, PaginatedResource, asyncData, RequestedPagination } from '@sentinel/common';\nimport { UserApi } from '@muni-kypo-crp/training-api';\nimport { throwError } from 'rxjs';\nimport { skip, take } from 'rxjs/operators';\nimport {\n  createContext,\n  createErrorHandlerSpy,\n  createUserApiSpy,\n} from '../../../../../internal/src/testing/testing-commons.spec';\nimport { TrainingErrorHandler } from '../../../../../src/services/training-error.handler.service';\nimport { TrainingAgendaContext } from '../../../../../internal/src/services/context/training-agenda-context.service';\nimport { AuthorsAssignService } from './authors-assign.service';\nimport { Designer } from '@muni-kypo-crp/training-model';\n\ndescribe('AuthorsAssignService', () => {\n  let errorHandlerSpy: jasmine.SpyObj<TrainingErrorHandler>;\n  let apiSpy: jasmine.SpyObj<UserApi>;\n  let service: AuthorsAssignService;\n  let context: TrainingAgendaContext;\n\n  beforeEach(async(() => {\n    errorHandlerSpy = createErrorHandlerSpy();\n    apiSpy = createUserApiSpy();\n    context = createContext();\n\n    TestBed.configureTestingModule({\n      providers: [\n        AuthorsAssignService,\n        { provide: UserApi, useValue: apiSpy },\n        { provide: TrainingErrorHandler, useValue: errorHandlerSpy },\n        { provide: TrainingAgendaContext, useValue: context },\n      ],\n    });\n    service = TestBed.inject(AuthorsAssignService);\n  }));\n\n  it('should be created', () => {\n    expect(service).toBeTruthy();\n  });\n\n  it('should load authors from facade (called once)', (done) => {\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const pagination = createPagination();\n    service.getAssigned(0, pagination).subscribe(() => done(), fail);\n    expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n  });\n\n  it('should load designers from facade (called once)', (done) => {\n    apiSpy.getDesignersNotInTD.and.returnValue(asyncData(createMock()));\n    service.getAvailableToAssign(0).subscribe(() => done(), fail);\n    expect(apiSpy.getDesignersNotInTD).toHaveBeenCalledTimes(1);\n  });\n\n  it('should assign designers through facade (called once)', (done) => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToAssign = createMock().elements;\n    const idsToAssign = usersToAssign.map((user) => user.id);\n    service.assign(0, usersToAssign).subscribe(() => done(), fail);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledTimes(1);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledWith(0, idsToAssign, false, []);\n  });\n\n  it('should refresh authors after assign action', (done) => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToAssign = createMock().elements;\n    service.assign(0, usersToAssign).subscribe(() => {\n      expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n      done();\n    }, fail);\n  });\n\n  it('should unassign authors through facade (called once)', (done) => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToUnassign = createMock().elements;\n    const idsToUnassign = usersToUnassign.map((user) => user.id);\n    service.unassign(0, usersToUnassign).subscribe(() => done(), fail);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledTimes(1);\n    expect(apiSpy.updateAuthors).toHaveBeenCalledWith(0, [], false, idsToUnassign);\n  });\n\n  it('should refresh authors after unassign action', (done) => {\n    apiSpy.updateAuthors.and.returnValue(asyncData(null));\n    apiSpy.getAuthors.and.returnValue(asyncData(createMock()));\n    const usersToUnassign = createMock().elements;\n    service.unassign(0, usersToUnassign).subscribe(() => {\n      expect(apiSpy.getAuthors).toHaveBeenCalledTimes(1);\n      done();\n    }, fail);\n  });\n\n  it('should call error handler on err (getAvailableToAssign)', (done) => {\n    apiSpy.getDesignersNotInTD.and.returnValue(throwError(null));\n    service.getAvailableToAssign(0).subscribe(\n      () => fail,\n      () => {\n        expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n        done();\n      }\n    );\n  });\n\n  it('should call error handler on err (getAssigned)', (done) => {\n    apiSpy.getAuthors.and.returnValue(throwError(null));\n    service.getAssigned(0, null).subscribe(\n      () => fail,\n      () => {\n        expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n        done();\n      }\n    );\n  });\n\n  it('should call error handler on err (assign)', (done) => {\n    apiSpy.updateAuthors.and.returnValue(throwError(null));\n    service.assign(0, []).subscribe(\n      () => fail,\n      () => {\n        expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n        done();\n      }\n    );\n  });\n\n  it('should call error handler on err (unassign)', (done) => {\n    apiSpy.updateAuthors.and.returnValue(throwError(null));\n    service.unassign(0, []).subscribe(\n      () => fail,\n      () => {\n        expect(errorHandlerSpy.emit).toHaveBeenCalledTimes(1);\n        done();\n      }\n    );\n  });\n\n  it('should emit hasError on err', (done) => {\n    apiSpy.getAuthors.and.returnValue(throwError(null));\n    const pagination = createPagination();\n    service.hasError$\n      .pipe(skip(2)) // we ignore initial value and value emitted before the call is made\n      .subscribe((emitted) => {\n        expect(emitted).toBeTruthy();\n        done();\n      }, fail);\n    service\n      .getAssigned(0, pagination)\n      .pipe(take(1))\n      .subscribe(fail, (_) => _);\n  });\n\n  it('should emit next value on getAuthors', (done) => {\n    const mockData = createMock();\n    apiSpy.getAuthors.and.returnValue(asyncData(mockData));\n    const pagination = createPagination();\n    service.assignedUsers$.pipe(skip(1)).subscribe((emitted) => {\n      expect(emitted).toBe(mockData);\n      done();\n    }, fail);\n    service\n      .getAssigned(0, pagination)\n      .pipe(take(1))\n      .subscribe((_) => _, fail);\n  });\n\n  function createPagination() {\n    return new RequestedPagination(1, 5, '', '');\n  }\n\n  function createMock() {\n    const user1: Designer = { id: 1, name: '', login: '', mail: '', picture: '' };\n    const user2: Designer = { id: 2, name: '', login: '', mail: '', picture: '' };\n    return new PaginatedResource([user1, user2], new SentinelPagination(1, 2, 5, 2, 1));\n  }\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}